# 멀티플레이어 좀비 아포칼립스 텍스트 어드벤처 게임


## 한 줄 소개
C와 ncurses로구현된 협동형 좀비 아포칼립스 생존 텍스트 어드벤처 게임


## 📚 목차
[소개](#소개)  
[주요 기능](#주요-기능)  
[설치 및 빌드](#설치-및-빌드)  
[사용 예시](#사용-예시)  
[프로젝트 구조](#프로젝트-구조)  
[아키텍처 및 코드 설명](#아키텍처-및-코드-설명)  
[저자](#저자)  
[참조](#참조)  


## 소개
“멀티플레이어 좀비 아포칼립스 텍스트 어드벤처 게임”은 시스템 프로그래밍 수업(ELEC462)의 기말 팀 프로젝트로 개발된 콘솔 기반 협동형 텍스트 어드벤처입니다. 기존의 싱글플레이 텍스트 게임과 달리, 여러 플레이어가 동시에 접속하여 분기형 스토리를 함께 탐험하고, 각자의 체력(HP)·경험치(EXP)·골드(Gold)·공격력(ATK)·방어력(DEF) 등의 상태를 관리하며, 다수결 투표를 통해 스토리 전개 방향을 결정합니다. 궁극적으로 플레이어들은 좀비가 득실대는 포스트 아포칼립스 세계에서 살아남기 위해 협력과 선택을 반복하며, 멀티(다양한) 엔딩을 경험하게 됩니다.


### 배경 및 목적
- #### 텍스트 어드벤처 장르의 확장
  1인용 텍스트 어드벤처 게임은 오랫동안 사랑받아 왔지만, 여러 명이 동시에 플레이하는 협동형 텍스트 환경은 비교적 드뭅니다.
  이 프로젝트는 여러 플레이어가 실시간으로 연결된 상태에서, 각자의 선택을 투표 시스템(다수결)으로 반영하여 공동 스토리를 만들어가는 재미를 구현하고자 합니다.

- #### 시스템 프로그래밍 기술 습득
  서버–클라이언트 모델, TCP/IP 소켓 프로그래밍, I/O 멀티플렉싱(select()), 파일 입출력(log 기록), 멀티바이트 문자 처리, 터미널 GUI(ncurses) 등 리눅스 시스템 프로그래밍 핵심 기술들을 모두 활용하여,
  실용적이고 안정적인 멀티플레이어 애플리케이션을 만드는 경험을 목표로 합니다.

- #### 게임 디자인 학습
  단순히 네트워크나 UI만 다루는 것이 아니라, 분기형 스토리 구조 설계, 플레이어 상태 변화(HP·EXP·골드·레벨업 등) 구현, 다양한 엔딩 및 밸런싱 요소를 조정하는 과정을 통해, 소프트웨어 기획과 설계 능력    도 함께 키우고자 합니다.



## 주요 기능
### 멀티플레이어 접속 관리
  여러 클라이언트가 동시에 서버에 접속하여 협동 플레이가 가능합니다.
- socket(), bind(), listen(), accept()를 통해 TCP 연결을 구성
- select() 및 FD_SET/FD_ISSET으로 모든 클라이언트 소켓 FD를 실시간 감시
- 클라이언트 접속·종료 이벤트 발생 시 FD_SET()/FD_CLR()으로 유연하게 처리

### 선택지 다수결 투표 시스템
  각 스테이지마다 모든 플레이어가 1~3번 중 하나의 선택지를 입력하고, 다수결로 최종 분기를 결정합니다.
- 클라이언트가 ctosPacket.select로 선택지를 서버에 전송
- 서버는 coop_event.selected[] 배열에 각 클라이언트 선택을 기록
- calculate_majority() 함수로 최다 득표 결과를 산출하고 다음 시나리오(next_scenario)로 분기
- 엔딩 스테이지에 도달하면 ENDING 명령을 전송하여 게임 종료 처리

### 서버 로그 기록
  게임 진행 중 발생하는 주요 이벤트를 모두 log.txt에 타임스탬프와 함께 기록하여, 디버깅 및 플레이 데이터 분석에 활용할 수 있습니다.
- save_log(const char *fmt, …) 하나의 함수로 모든 로그 출력 통합 관리
- 로그 항목: 접속(접속/연결종료), 게임 시작, 선택 완료, 결과, 채팅, 레벨업, 서버 종료 등
- time(), localtime(), va_list 등을 사용해 “[MM-DD HH:MM:SS] 메시지” 형식으로 저장

### ncurses 기반 터미널 UI
  콘솔 창을 세 영역으로 분리하여, 스토리·채팅·입력을 동시에 확인할 수 있는 직관적인 GUI를 제공합니다.
- game_win: 시나리오, 선택지, 결과, 플레이어 상태(HP/EXP/Gold 등) 출력
- chat_win: 다른 플레이어의 채팅 메시지를 실시간 출력(스크롤 지원)
- input_win: 메시지 입력 또는 선택지 번호(1~3) 입력 처리, 남은 시간 타이머 표시
- setlocale(LC_ALL, "")로 한글 출력 지원, print_game()과 print_chat()으로 멀티바이트 자동 줄바꿈 구현
- 200ms 주기 select() 루프와 wgetch()를 결합해 “남은 시간 표시 → 키 입력 → 서버 이벤트”를 동시에 처리

### 플레이어 상태 관리 & 레벨업 시스템
  각 플레이어는 HP, 레벨, EXP, 골드, 공격력, 방어력 등의 상태를 실시간으로 갱신합니다.
- user_status 구조체에 모든 상태 정보를 저장하고, change_status() 함수로 보상(HP/EXP/골드 등) 적용
- EXP가 100 이상 모이면 자동 레벨업 → 공격력 +2, 방어력 +1 증가
- 상태 변화 발생 시에도 save_log()를 호출하여 “[상태변화] 닉네임: HP:100 EXP:20 Gold:50 ATK:12 DEF:6 LV:2” 형식으로 기록

## 설치 및 빌드
  아래 절차에 따라 프로젝트를 로컬에 클론하고, 서버와 클라이언트를 각각 빌드한 뒤 실행할 수 있습니다.

### 1. 의존성(Dependencies) 설치
- 운영 체제: Linux (Ubuntu 20.04 이상 권장)
- 필요 패키지:
  - GNU C 컴파일러 (gcc)
  - ncurses 개발 헤더 (libncursesw5-dev)
  - Make (Makefile을 사용하는 경우)

### 2. 리포지토리 클론
  프로젝트 전체를 로컬로 가져옵니다.

### 3. 서버(Server) 빌드 및 실행
 프로젝트 최상위 디렉터리에 미리 제공된 server.sh 스크립트를 이용하면, 소스 컴파일부터 서버 실행까지 한 번에 할 수 있습니다.
- server.sh에 실행 권한이 없다면 부여합니다. (최초 한 번만 필요)
  - chmod +x server.sh
- bash server.sh 또는 ./server.sh 명령으로 서버를 컴파일하고 바로 실행합니다:
  - bash server.sh
내부 동작:

server.c를 gcc -std=c11 -Wall -Wextra -o server server.c로 컴파일

컴파일이 성공하면 설정된 기본 포트(스크립트 내부의 PORT=9190)로 서버 프로세스를 실행

터미널에 “서버 실행 중 (포트: 9190)” 메시지가 뜨면, 정상적으로 서버가 대기 중인 상태입니다.

클라이언트 실행 (bash 스크립트 이용)
마찬가지로 클라이언트도 client.sh 스크립트를 사용하여 컴파일·실행할 수 있습니다.

별도의 터미널 창(또는 탭)을 열고, 프로젝트 루트 디렉터리로 이동:

cd REPO
client.sh에 실행 권한이 없다면 부여합니다. (최초 한 번만 필요)

chmod +x client.sh
bash client.sh 또는 ./client.sh 명령으로 클라이언트를 컴파일하고 실행합니다:

bash client.sh
내부 동작:





./client 127.0.0.1 9190
실행하면 ncurses 기반의 터미널 UI가 뜨고,
“닉네임을 입력하세요:” 프롬프트가 표시됩니다.

5. 서버와 클라이언트 동시 실행 예시
터미널 A (서버 실행):


cd REPO/server
./server 9190
터미널 B (클라이언트 1 실행):


cd REPO/client
./client 127.0.0.1 9190
터미널 C (클라이언트 2 실행):

cd REPO/client
./client 127.0.0.1 9190
두 개 이상의 클라이언트가 접속할 때마다, 서버 로그(log.txt)에 자동으로 기록됩니다.

반드시 서버가 먼저 실행된 상태에서 클라이언트를 실행해야 정상적으로 접속할 수 있습니다.

이제 설치와 빌드가 완료되었습니다. 다음 절차(사용 예시, 프로젝트 구조 등)를 참조하여 실제 게임을 플레이하거나 추가 개발을 진행할 수 있습니다.

## 사용 예시

## 프로젝트 구조

## 아키텍처 및 코드 설명

## 저자

## 참조

