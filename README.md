# 멀티플레이어 좀비 아포칼립스 텍스트 어드벤처 게임


## 한 줄 소개
C와 ncurses로구현된 협동형 좀비 아포칼립스 생존 텍스트 어드벤처 게임


## 📚 목차
[소개](#소개)  
[배경 및 목적](#배경-및-목적)
[주요 기능](#주요-기능)  
[설치 및 빌드](#설치-및-빌드)  
[사용 예시](#사용-예시)  
[프로젝트 구조](#프로젝트-구조)  
[아키텍처 및 코드 설명](#아키텍처-및-코드-설명)  
[저자](#저자)  
[참조](#참조)  


## 소개
“멀티플레이어 좀비 아포칼립스 텍스트 어드벤처 게임”은 시스템 프로그래밍 수업(ELEC462)의 기말 팀 프로젝트로 개발된 콘솔 기반 협동형 텍스트 어드벤처입니다. 기존의 싱글플레이 텍스트 게임과 달리, 여러 플레이어가 동시에 접속하여 분기형 스토리를 함께 탐험하고, 각자의 체력(HP)·경험치(EXP)·골드(Gold)·공격력(ATK)·방어력(DEF) 등의 상태를 관리하며, 다수결 투표를 통해 스토리 전개 방향을 결정합니다. 궁극적으로 플레이어들은 좀비가 득실대는 포스트 아포칼립스 세계에서 살아남기 위해 협력과 선택을 반복하며, 다양한 엔딩을 경험하게 됩니다.


## 배경 및 목적
- ### 텍스트 어드벤처 장르의 확장
  1인용 텍스트 어드벤처 게임은 오랫동안 사랑받아 왔지만, 여러 명이 동시에 플레이하는 협동형 텍스트 환경은 비교적 드뭅니다.
  이 프로젝트는 여러 플레이어가 실시간으로 연결된 상태에서, 각자의 선택을 투표 시스템(다수결)으로 반영하여 공동 스토리를 만들어가는 재미를 구현하고자 합니다.

- ### 시스템 프로그래밍 기술 습득
  서버–클라이언트 모델, TCP/IP 소켓 프로그래밍, I/O 멀티플렉싱(select()), 파일 입출력(log 기록), 멀티바이트 문자 처리, 터미널 GUI(ncurses) 등 리눅스 시스템 프로그래밍 핵심 기술들을 모두 활용하여,
  실용적이고 안정적인 멀티플레이어 애플리케이션을 만드는 경험을 목표로 합니다.

- ### 게임 디자인 학습
  단순히 네트워크나 UI만 다루는 것이 아니라, 분기형 스토리 구조 설계, 플레이어 상태 변화(HP·EXP·골드·레벨업 등) 구현, 다양한 엔딩 및 밸런싱 요소를 조정하는 과정을 통해, 소프트웨어 기획과 설계 능력    도 함께 키우고자 합니다.



## 주요 기능
### 멀티플레이어 접속 관리
  여러 클라이언트가 동시에 서버에 접속하여 협동 플레이가 가능합니다.
- socket(), bind(), listen(), accept()를 통해 TCP 연결을 구성
- select() 및 FD_SET/FD_ISSET으로 모든 클라이언트 소켓 FD를 실시간 감시
- 클라이언트 접속·종료 이벤트 발생 시 FD_SET()/FD_CLR()으로 유연하게 처리

### 선택지 다수결 투표 시스템
  각 스테이지마다 모든 플레이어가 1~3번 중 하나의 선택지를 입력하고, 다수결로 최종 분기를 결정합니다.
- 클라이언트가 ctosPacket.select로 선택지를 서버에 전송
- 서버는 coop_event.selected[] 배열에 각 클라이언트 선택을 기록
- calculate_majority() 함수로 최다 득표 결과를 산출하고 다음 시나리오(next_scenario)로 분기
- 엔딩 스테이지에 도달하면 ENDING 명령을 전송하여 게임 종료 처리

### 서버 로그 기록
  게임 진행 중 발생하는 주요 이벤트를 모두 log.txt에 타임스탬프와 함께 기록하여, 디버깅 및 플레이 데이터 분석에 활용할 수 있습니다.
- save_log(const char *fmt, …) 하나의 함수로 모든 로그 출력 통합 관리
- 로그 항목: 접속(접속/연결종료), 게임 시작, 선택 완료, 결과, 채팅, 레벨업, 서버 종료 등
- time(), localtime(), va_list 등을 사용해 “[MM-DD HH:MM:SS] 메시지” 형식으로 저장

### ncurses 기반 터미널 UI
  콘솔 창을 세 영역으로 분리하여, 스토리·채팅·입력을 동시에 확인할 수 있는 직관적인 GUI를 제공합니다.
- game_win: 시나리오, 선택지, 결과, 플레이어 상태(HP/EXP/Gold 등) 출력
- chat_win: 다른 플레이어의 채팅 메시지를 실시간 출력(스크롤 지원)
- input_win: 메시지 입력 또는 선택지 번호(1~3) 입력 처리, 남은 시간 타이머 표시
- setlocale(LC_ALL, "")로 한글 출력 지원, print_game()과 print_chat()으로 멀티바이트 자동 줄바꿈 구현
- 200ms 주기 select() 루프와 wgetch()를 결합해 “남은 시간 표시 → 키 입력 → 서버 이벤트”를 동시에 처리

### 플레이어 상태 관리 & 레벨업 시스템
  각 플레이어는 HP, 레벨, EXP, 골드, 공격력, 방어력 등의 상태를 실시간으로 갱신합니다.
- user_status 구조체에 모든 상태 정보를 저장하고, change_status() 함수로 보상(HP/EXP/골드 등) 적용
- EXP가 100 이상 모이면 자동 레벨업 → 공격력 +2, 방어력 +1 증가
- 상태 변화 발생 시에도 save_log()를 호출하여 “[상태변화] 닉네임: HP:100 EXP:20 Gold:50 ATK:12 DEF:6 LV:2” 형식으로 기록


## 설치 및 빌드
  아래 절차에 따라 프로젝트를 로컬에 클론하고, 서버와 클라이언트를 각각 빌드한 뒤 실행할 수 있습니다.

### 1. 의존성(Dependencies) 설치
- 운영 체제: Linux (Ubuntu 20.04 이상 권장)
- 필요한 패키지:
  GNU C 컴파일러 (gcc)
  ncurses 개발 헤더 (libncursesw5-dev)
  Make
- 설치
  sudo apt update
  sudo apt install -y gcc libncursesw5-dev make

### 2. 리포지토리 클론
  git clone <REPO_URL>
  
### 3. 빌드(Build) 및 실행(Run)
  프로젝트 루트 디렉터리에 있는 Makefile을 이용해 서버와 클라이언트를 개별적으로 빌드 및 실행할 수 있습니다.

- 서버 빌드·실행
  make run-server
- 내부 동작:
  make server → server 바이너리 컴파일
  ./server 9190 → 포트 9190으로 서버 실행

- 클라이언트 빌드·실행
  make run-client
- 내부 동작:
  make client → client 바이너리 컴파일
  ./client 127.0.0.1 9190 → 로컬호스트 9190번 포트의 서버에 접속

### 4. 참고
- 서버가 먼저 실행되어 있어야 클라이언트가 정상 접속합니다.
- 다수의 클라이언트를 실행하려면, 다른 터미널에서 동일 명령을 반복 실행하세요.
- 접속 기록은 log.txt에 자동으로 기록됩니다.


## 사용 예시

## 프로젝트 구조

## 아키텍처 및 코드 설명

## 저자

## 참조

